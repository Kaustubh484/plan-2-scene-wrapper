"""
CPU-Friendly Texture Mapper
Uses existing texture crops from Rent3D++ dataset instead of neural synthesis
"""

import random
import shutil
from pathlib import Path
from typing import Dict, List, Tuple
import logging

logger = logging.getLogger(__name__)


class TextureMapper:
    """Map existing texture crops to 3D surfaces"""
    
    def __init__(self, data_path: Path):
        self.data_path = data_path
        self.crops_path = data_path / 'processed/surface_crops'
        self.textures_path = data_path / 'textures/stationary_textures_dataset_v2'
        
    def get_texture_for_surface(self, surface_type: str, house_id: str) -> Path:
        """
        Get a texture crop for a given surface type
        
        Args:
            surface_type: 'floor', 'ceiling', or 'wall'
            house_id: House ID to get crops from
            
        Returns:
            Path to texture image
        """
        surface_dir = self.crops_path / surface_type
        
        if not surface_dir.exists():
            logger.warning(f"Surface directory not found: {surface_dir}")
            return self._get_fallback_texture(surface_type)
        
        # Get crops for this house
        house_crops = list(surface_dir.glob(f'{house_id}_*.png'))
        
        if not house_crops:
            logger.info(f"No {surface_type} crops for house {house_id}, using fallback")
            return self._get_fallback_texture(surface_type)
        
        # Pick a random crop
        return random.choice(house_crops)
    
    def _get_fallback_texture(self, surface_type: str) -> Path:
        """Get a fallback texture from stationary textures dataset"""
        
        # Map surface types to substance types
        substance_map = {
            'floor': 'Wood',
            'ceiling': 'Plastered', 
            'wall': 'Plastered'
        }
        
        substance = substance_map.get(surface_type, 'Wood')
        train_dir = self.textures_path / 'train'
        
        if not train_dir.exists():
            logger.error("Stationary textures not found")
            return None
        
        # Get textures of this substance
        textures = list(train_dir.glob(f'{substance}_*.jpg'))
        
        if textures:
            return random.choice(textures)
        
        # Last resort: any texture
        all_textures = list(train_dir.glob('*.jpg'))
        return random.choice(all_textures) if all_textures else None
    
    def create_textured_obj(
        self, 
        house_id: str,
        architecture: dict,
        output_dir: Path
    ) -> Tuple[Path, Path, Dict[str, Path]]:
        """
        Create OBJ file with textures and MTL material file
        
        Returns:
            (obj_file, mtl_file, texture_files_dict)
        """
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
        
        obj_file = output_dir / 'model.obj'
        mtl_file = output_dir / 'model.mtl'
        textures_dir = output_dir / 'textures'
        textures_dir.mkdir(exist_ok=True)
        
        # Collect textures
        texture_files = {}
        for surface_type in ['floor', 'ceiling', 'wall']:
            texture_path = self.get_texture_for_surface(surface_type, house_id)
            if texture_path and texture_path.exists():
                # Copy to output
                dest = textures_dir / f'{surface_type}.png'
                shutil.copy(texture_path, dest)
                texture_files[surface_type] = dest
                logger.info(f"Using texture for {surface_type}: {texture_path.name}")
        
        # Generate MTL file
        self._create_mtl_file(mtl_file, texture_files)
        
        # Generate OBJ with UV coordinates
        self._create_obj_with_uv(obj_file, mtl_file, architecture, house_id)
        
        return obj_file, mtl_file, texture_files
    
    def _create_mtl_file(self, mtl_file: Path, texture_files: Dict[str, Path]):
        """Create MTL material file"""
        
        mtl_content = [
            "# Material file generated by Plan2Scene",
            "# Textures from Rent3D++ dataset",
            ""
        ]
        
        for surface_type, texture_path in texture_files.items():
            material_name = f"material_{surface_type}"
            relative_texture = f"textures/{texture_path.name}"
            
            mtl_content.extend([
                f"newmtl {material_name}",
                "Ka 1.0 1.0 1.0",  # Ambient
                "Kd 0.8 0.8 0.8",  # Diffuse
                "Ks 0.2 0.2 0.2",  # Specular
                "Ns 50.0",          # Shininess
                f"map_Kd {relative_texture}",  # Texture map
                ""
            ])
        
        mtl_file.write_text('\n'.join(mtl_content))
        logger.info(f"Created MTL file: {mtl_file}")
    
    def _create_obj_with_uv(
        self, 
        obj_file: Path, 
        mtl_file: Path,
        architecture: dict,
        house_id: str
    ):
        """Create OBJ file with UV coordinates and material assignments"""
        
        obj_lines = [
            f"# Plan2Scene Textured Model",
            f"# House: {house_id}",
            f"# Generated with CPU-friendly texture mapping",
            f"mtllib {mtl_file.name}",
            ""
        ]
        
        vertex_index = 1
        uv_index = 1
        
        try:
            scene = architecture.get('scene', {})
            arch = scene.get('arch', {})
            elements = arch.get('elements', [])
            
            # Group by room
            rooms = {}
            for element in elements:
                room_id = element.get('roomId', 'unknown')
                element_type = element.get('type', 'unknown')
                
                if room_id not in rooms:
                    rooms[room_id] = {'floor': None, 'ceiling': None, 'walls': []}
                
                if element_type == 'Floor':
                    rooms[room_id]['floor'] = element
                elif element_type == 'Ceiling':
                    rooms[room_id]['ceiling'] = element
                elif element_type == 'Wall':
                    rooms[room_id]['walls'].append(element)
            
            # Generate geometry for each room
            for room_id, room_data in rooms.items():
                obj_lines.append(f"# Room: {room_id}")
                
                floor_elem = room_data['floor']
                ceiling_elem = room_data['ceiling']
                
                if not (floor_elem and ceiling_elem):
                    continue
                
                floor_points = floor_elem.get('points', [[]])[0]
                ceiling_offset = ceiling_elem.get('offset', [0, 2.8, 0])
                ceiling_height = ceiling_offset[1]
                
                if len(floor_points) < 3:
                    continue
                
                # FLOOR
                obj_lines.append("usemtl material_floor")
                floor_verts = []
                for point in floor_points:
                    x, y, z = point[0], point[1], point[2]
                    obj_lines.append(f"v {x} {y} {z}")
                    floor_verts.append(vertex_index)
                    vertex_index += 1
                
                # UV coordinates for floor (simple planar mapping)
                for i, point in enumerate(floor_points):
                    u = (point[0] % 5.0) / 5.0  # Repeat every 5 units
                    v = (point[2] % 5.0) / 5.0
                    obj_lines.append(f"vt {u} {v}")
                
                # Floor face with UV
                uv_indices = list(range(uv_index, uv_index + len(floor_points)))
                face_def = " ".join(f"{floor_verts[i]}/{uv_indices[i]}" for i in range(len(floor_points)))
                obj_lines.append(f"f {face_def}")
                uv_index += len(floor_points)
                
                # CEILING
                obj_lines.append("usemtl material_ceiling")
                ceiling_verts = []
                for point in floor_points:
                    x, y, z = point[0], point[1] + ceiling_height, point[2]
                    obj_lines.append(f"v {x} {y} {z}")
                    ceiling_verts.append(vertex_index)
                    vertex_index += 1
                
                # UV for ceiling
                for i, point in enumerate(floor_points):
                    u = (point[0] % 5.0) / 5.0
                    v = (point[2] % 5.0) / 5.0
                    obj_lines.append(f"vt {u} {v}")
                
                # Ceiling face (reversed winding)
                uv_indices = list(range(uv_index, uv_index + len(floor_points)))
                face_def = " ".join(f"{ceiling_verts[i]}/{uv_indices[i]}" for i in reversed(range(len(floor_points))))
                obj_lines.append(f"f {face_def}")
                uv_index += len(floor_points)
                
                # WALLS
                obj_lines.append("usemtl material_wall")
                num_points = len(floor_points)
                for i in range(num_points):
                    next_i = (i + 1) % num_points
                    
                    # Wall quad vertices (already created above)
                    # Just need to add UVs and face
                    
                    # UV coordinates for wall quad
                    obj_lines.append("vt 0 0")
                    obj_lines.append("vt 1 0")
                    obj_lines.append("vt 1 1")
                    obj_lines.append("vt 0 1")
                    
                    # Wall face with UVs
                    v1, v2 = floor_verts[i], floor_verts[next_i]
                    v3, v4 = ceiling_verts[next_i], ceiling_verts[i]
                    
                    uv_base = uv_index
                    obj_lines.append(f"f {v1}/{uv_base} {v2}/{uv_base+1} {v3}/{uv_base+2} {v4}/{uv_base+3}")
                    uv_index += 4
                
                obj_lines.append("")
        
        except Exception as e:
            logger.error(f"Error generating textured OBJ: {e}", exc_info=True)
            # Fallback to simple cube
            obj_lines.extend([
                "# Fallback geometry",
                "usemtl material_wall",
                "v -5 0 -5", "v 5 0 -5", "v 5 0 5", "v -5 0 5",
                "v -5 3 -5", "v 5 3 -5", "v 5 3 5", "v -5 3 5",
                "vt 0 0", "vt 1 0", "vt 1 1", "vt 0 1",
                "f 1/1 2/2 3/3 4/4",
                "f 1/1 2/2 6/3 5/4", "f 2/1 3/2 7/3 6/4",
                "f 3/1 4/2 8/3 7/4", "f 4/1 1/2 5/3 8/4",
                "f 5/1 6/2 7/3 8/4"
            ])
        
        obj_file.write_text('\n'.join(obj_lines))
        logger.info(f"Created textured OBJ: {obj_file}")
